It's a place for notes about pintos components, that are new for us

1) interrupt.h
enum intr_level { INTR_OFF, INTR_ON }; //are interrupts enabled?
enum intr_level intr_get_level (void); 
enum intr_level intr_set_level (enum intr_level);
enum intr_level intr_enable (void);
enum intr_level intr_disable (void);

/* Interrupt stack frame. */
struct intr_frame
{
    /* Pushed by intr_entry in intr-stubs.S.
     These are the interrupted task's saved registers. */
     uint32_t edi;               /* Saved EDI. */
     uint32_t esi;               /* Saved ESI. */
     uint32_t ebp;               /* Saved EBP. */
     uint32_t esp_dummy;         /* Not used. */
     uint32_t ebx;               /* Saved EBX. */
     uint32_t edx;               /* Saved EDX. */
     uint32_t ecx;               /* Saved ECX. */
     uint32_t eax;               /* Saved EAX. */
     uint16_t gs, :16;           /* Saved GS segment register. */
     uint16_t fs, :16;           /* Saved FS segment register. */
     uint16_t es, :16;           /* Saved ES segment register. */
     uint16_t ds, :16;           /* Saved DS segment register. */
     /* Pushed by intrNN_stub in intr-stubs.S. */
     uint32_t vec_no;            /* Interrupt vector number. */

     /* Sometimes pushed by the CPU,
     otherwise for consistency pushed as 0 by intrNN_stub.
     The CPU puts it just under `eip', but we move it here. */
     uint32_t error_code;        /* Error code. */

     /* Pushed by intrNN_stub in intr-stubs.S.
     This frame pointer eases interpretation of backtraces. */
     void *frame_pointer;        /* Saved EBP (frame pointer). */

     /* Pushed by the CPU.
     These are the interrupted task's saved registers. */
     void (*eip) (void);         /* Next instruction to execute. */
     uint16_t cs, :16;           /* Code segment for eip. */
     uint32_t eflags;            /* Saved CPU flags. */
     void *esp;                  /* Saved stack pointer. */
     uint16_t ss, :16;           /* Data segment for esp. */
};

typedef void intr_handler_func (struct intr_frame *);

void intr_init (void);
void intr_register_ext (uint8_t vec, intr_handler_func *, const char *name);
void intr_register_int (uint8_t vec, int dpl, enum intr_level,
                        intr_handler_func *, const char *name);
bool intr_context (void);
void intr_yield_on_return (void);

void intr_dump_frame (const struct intr_frame *);
const char *intr_name (uint8_t vec);


2) io.h
/* Reads and returns a byte from PORT. */
static inline uint8_t inb (uint16_t port)

/* Reads CNT bytes from PORT, one after another, and stores them
   into the buffer starting at ADDR. */
static inline void insb (uint16_t port, void *addr, size_t cnt)

/* Reads and returns 16 bits from PORT. */
static inline uint16_t inw (uint16_t port)

/* Reads CNT 16-bit (halfword) units from PORT, one after
   another, and stores them into the buffer starting at ADDR. */
static inline void insw (uint16_t port, void *addr, size_t cnt)

/* Reads and returns 32 bits from PORT. */
static inline uint32_t inl (uint16_t port)

/* Reads CNT 32-bit (word) units from PORT, one after another,
   and stores them into the buffer starting at ADDR. */
static inline void insl (uint16_t port, void *addr, size_t cnt)

/* Writes byte DATA to PORT. */
static inline void outb (uint16_t port, uint8_t data)

/* Writes to PORT each byte of data in the CNT-byte buffer
starting at ADDR. */
static inline void outsb (uint16_t port, const void *addr, size_t cnt)

/* Writes the 16-bit DATA to PORT. */
static inline void outw (uint16_t port, uint16_t data)

/* Writes to PORT each 16-bit unit (halfword) of data in the
CNT-halfword buffer starting at ADDR. */
static inline void outsw (uint16_t port, const void *addr, size_t cnt)

/* Writes the 32-bit DATA to PORT. */
static inline void outl (uint16_t port, uint32_t data)

/* Writes to PORT each 32-bit unit (word) of data in the CNT-word
buffer starting at ADDR. */
static inline void outsl (uint16_t port, const void *addr, size_t cnt)

3) malloc,h
void malloc_init (void);
void *malloc (size_t) __attribute__ ((malloc));
void *calloc (size_t, size_t) __attribute__ ((malloc));
void *realloc (void *, size_t);
void free (void *); 

4) palloc.h
/* How to allocate pages. */
enum palloc_flags
{
    PAL_ASSERT = 001,           /* Panic on failure. */
    PAL_ZERO = 002,             /* Zero page contents. */
    PAL_USER = 004              /* User page. */
};  

void palloc_init (size_t user_page_limit);
void *palloc_get_page (enum palloc_flags);
void *palloc_get_multiple (enum palloc_flags, size_t page_cnt);
void palloc_free_page (void *); 
void palloc_free_multiple (void *, size_t page_cnt);

5) pte.h
/* Functions and macros for working with x86 hardware page
   tables.

   See vaddr.h for more generic functions and macros for virtual
   addresses.
            
   Virtual addresses are structured as follows:

    31                  22 21                  12 11                   0
   +----------------------+----------------------+----------------------+
   | Page Directory Index |   Page Table Index   |    Page Offset       |
   +----------------------+----------------------+----------------------+
*/

/* Page table index (bits 12:21). */
#define PTSHIFT PGBITS                     /* First page table bit. */
#define PTBITS  10                         /* Number of page table bits. */
#define PTSPAN  (1 << PTBITS << PGBITS)    /* Bytes covered by a page table. */
#define PTMASK  BITMASK(PTSHIFT, PTBITS)   /* Page table bits (12:21). */

/* Page directory index (bits 22:31). */
#define PDSHIFT (PTSHIFT + PTBITS)         /* First page directory bit. */
#define PDBITS  10                         /* Number of page dir bits. */
#define PDMASK  BITMASK(PDSHIFT, PDBITS)   /* Page directory bits (22:31). */

/* Obtains page table index from a virtual address. */
static inline unsigned pt_no (const void *va)

/* Obtains page directory index from a virtual address. */
static inline uintptr_t pd_no (const void *va)

/* Page directory and page table entries.

For more information see the section on page tables in the
Pintos reference guide chapter, or [IA32-v3a] 3.7.6
"Page-Directory and Page-Table Entries".

PDEs and PTEs share a common format:

31                                 12 11                     0
+------------------------------------+------------------------+
|         Physical Address           |         Flags          |
+------------------------------------+------------------------+

In a PDE, the physical address points to a page table.
In a PTE, the physical address points to a data or code page.
The important flags are listed below.
When a PDE or PTE is not "present", the other flags are
ignored.
A PDE or PTE that is initialized to 0 will be interpreted as
"not present", which is just fine. */

#define PTE_FLAGS 0x00000fff    /* Flag bits. */
#define PTE_ADDR  0xfffff000    /* Address bits. */
#define PTE_AVL   0x00000e00    /* Bits available for OS use. */
#define PTE_P 0x1               /* 1=present, 0=not present. */
#define PTE_W 0x2               /* 1=read/write, 0=read-only. */
#define PTE_U 0x4               /* 1=user/kernel, 0=kernel only. */
#define PTE_A 0x20              /* 1=accessed, 0=not acccessed. */
#define PTE_D 0x40              /* 1=dirty, 0=not dirty (PTEs only). */

/* Returns a PDE that points to page table PT. */
static inline uint32_t pde_create (uint32_t *pt)

/* Returns a pointer to the page table that page directory entry
PDE, which must "present", points to. */
static inline uint32_t *pde_get_pt (uint32_t pde)

/* Returns a PTE that points to PAGE.
The PTE's page is readable.
If WRITABLE is true then it will be writable as well.
The page will be usable only by ring 0 code (the kernel). */
static inline uint32_t pte_create_kernel (void *page, bool writable)

/* Returns a PTE that points to PAGE.
The PTE's page is readable.
If WRITABLE is true then it will be writable as well.
The page will be usable by both user and kernel code. */
static inline uint32_t pte_create_user (void *page, bool writable)

/* Returns a pointer to the page that page table entry PTE points to. */
static inline void *pte_get_page (uint32_t pte)

6) sync.h
/* A counting semaphore. */
struct semaphore 
{
    unsigned value;             /* Current value. */
    struct list waiters;        /* List of waiting threads. */
};  

void sema_init (struct semaphore *, unsigned value);
void sema_down (struct semaphore *); 
bool sema_try_down (struct semaphore *); 
void sema_up (struct semaphore *); 
void sema_self_test (void);

/* Lock. */
struct lock 
{
    struct thread *holder;      /* Thread holding lock (for debugging). */
    struct semaphore semaphore; /* Binary semaphore controlling access. */
};  

void lock_init (struct lock *); 
void lock_acquire (struct lock *); 
bool lock_try_acquire (struct lock *); 
void lock_release (struct lock *); 
bool lock_held_by_current_thread (const struct lock *); 

/* Condition variable. */
struct condition 
{
    struct list waiters;        /* List of waiting threads. */
};  

void cond_init (struct condition *); 
void cond_wait (struct condition *, struct lock *); 
void cond_signal (struct condition *, struct lock *); 
void cond_broadcast (struct condition *, struct lock *); 

/* Optimization barrier.
   The compiler will not reorder operations across an
   optimization barrier.  See "Optimization Barriers" in the
   reference guide for more information.*/
#define barrier() asm volatile ("" : : : "memory")

7) thread.h
/* States in a thread's life cycle. */
enum thread_status
{
    THREAD_RUNNING,     /* Running thread. */
    THREAD_READY,       /* Not running but ready to run. */
    THREAD_BLOCKED,     /* Waiting for an event to trigger. */
    THREAD_DYING        /* About to be destroyed. */
}; 

/* Thread identifier type.
  You can redefine this to whatever type you like. */
typedef int tid_t;
#define TID_ERROR ((tid_t) -1)          /* Error value for tid_t. */

/* Thread priorities. */
#define PRI_MIN 0                       /* Lowest priority. */
#define PRI_DEFAULT 31                  /* Default priority. */
#define PRI_MAX 63                      /* Highest priority. */

struct thread
{
    /* Owned by thread.c. */
    tid_t tid;                          /* Thread identifier. */
    enum thread_status status;          /* Thread state. */
    char name[16];                      /* Name (for debugging purposes). */
    uint8_t *stack;                     /* Saved stack pointer. */
    int priority;                       /* Priority. */
    struct list_elem allelem;           /* List element for all threads list. */

    /* Shared between thread.c and synch.c. */
    struct list_elem elem;              /* List element. */

    #ifdef USERPROG
        /* Owned by userprog/process.c. */
        uint32_t *pagedir;                  /* Page directory. */
    #endif

    /* Owned by thread.c. */
    unsigned magic;                     /* Detects stack overflow. */
};

/* If false (default), use round-robin scheduler.
If true, use multi-level feedback queue scheduler.
Controlled by kernel command-line option "-o mlfqs". */
extern bool thread_mlfqs;

void thread_init (void);
void thread_start (void);

void thread_tick (void);
void thread_print_stats (void);

typedef void thread_func (void *aux);
tid_t thread_create (const char *name, int priority, thread_func *, void *);

void thread_block (void);
void thread_unblock (struct thread *);

struct thread *thread_current (void);
tid_t thread_tid (void);
const char *thread_name (void);

void thread_exit (void) NO_RETURN;
void thread_yield (void);

/* Performs some operation on thread t, given auxiliary data AUX. */
typedef void thread_action_func (struct thread *t, void *aux);
void thread_foreach (thread_action_func *, void *);

int thread_get_priority (void);
void thread_set_priority (int);

int thread_get_nice (void);
void thread_set_nice (int);
int thread_get_recent_cpu (void);
int thread_get_load_avg (void);

8) vaddr.h

/* Functions and macros for working with virtual addresses.

   See pte.h for functions and macros specifically for x86
   hardware page tables. */

#define BITMASK(SHIFT, CNT) (((1ul << (CNT)) - 1) << (SHIFT))

/* Page offset (bits 0:12). */
#define PGSHIFT 0                          /* Index of first offset bit. */
#define PGBITS  12                         /* Number of offset bits. */
#define PGSIZE  (1 << PGBITS)              /* Bytes in a page. */
#define PGMASK  BITMASK(PGSHIFT, PGBITS)   /* Page offset bits (0:12). */

/* Offset within a page. */
static inline unsigned pg_ofs (const void *va)

/* Virtual page number. */
static inline uintptr_t pg_no (const void *va)

/* Round up to nearest page boundary. */
static inline void *pg_round_up (const void *va)

/* Round down to nearest page boundary. */
static inline void *pg_round_down (const void *va)
              
/* Base address of the 1:1 physical-to-virtual mapping.  Physical
memory is mapped starting at this virtual address.  Thus,
physical address 0 is accessible at PHYS_BASE, physical
address address 0x1234 at (uint8_t *) PHYS_BASE + 0x1234, and so on.

This address also marks the end of user programs' address
space.  Up to this point in memory, user programs are allowed
to map whatever they like.  At this point and above, the
virtual address space belongs to the kernel. */

#define PHYS_BASE ((void *) LOADER_PHYS_BASE)

/* Returns true if VADDR is a user virtual address. */
static inline bool is_user_vaddr (const void *vaddr) 
                                        
/* Returns true if VADDR is a kernel virtual address. */
static inline bool is_kernel_vaddr (const void *vaddr) 

/* Returns kernel virtual address at which physical address PADDR
is mapped. */
static inline void* ptov (uintptr_t paddr)

/* Returns physical address at which kernel virtual address VADDR
is mapped. */
static inline uintptr_t vtop (const void *vaddr)
